# Perfect XOR

If we try to run this, we would eventually get the flag, but it's really slow, so let's try to not do that.

If we take a look at the a() function, we can see that it

- Has a loop that goes from 1 to n (for i in range)
- Defines b to be 0
  - Checks if i is a multiple of n
    - If so, add i to b
  - If b is equal to n, return True
```python
def a(n):
    b = 0
    for i in range(1, n):
        if(n % i == 0):
            b += i
    return b == n
```

We can see (and also guessing by the title) that this will only return true on perfect numbers. Knowing this, I just looked up a list of perfect numbers, and then just XORed each number with the corresponding perfect number. 

Script below.
```python
cipher = [list of base64decoded stuff]
p = [6,28,496,8128,33550336,8589869056,137438691328,2305843008139952128,2658455991569831744654692615953842176,191561942608236107294793378084303638130997321548169216,13164036458569648337239753460458722910223472318386943117783728128,14474011154664524427946373126085988481573677491474835889066354349131199152128,23562723457267347065789548996709904988477547858392600710143027597506337283178622239730365539602600561360255566462503270175052892578043215543382498428777152427010394496918664028644534128033831439790236838624033171435922356643219703101720713163527487298747400647801939587165936401087419375649057918549492160555646976,141053783706712069063207958086063189881486743514715667838838675999954867742652380114104193329037690251561950568709829327164087724366370087116731268159313652487450652439805877296207297446723295166658228846926807786652870188920867879451478364569313922060370695064736073572378695176473055266826253284886383715072974324463835300053138429460296575143368065570759537328128]
o = ""
for i in range(len(p)):
  o += (chr(p[i] ^ cipher[i]))

print(o)
```
Then we just wrap the output with flag and submit it

#### Flag: flag{tHE_br0kEN_Xor}
